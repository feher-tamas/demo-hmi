/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-function-return-type */
// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers'

export enum EventType {
  NONE = 0,
  CreateGeodataFinished = 1,
  ModifyGeodataFinished = 2,
  DeleteGeodataFinished = 3
}

export function unionToEventType(
  type: EventType,
  accessor: (
    obj: CreateGeodataFinished | DeleteGeodataFinished | ModifyGeodataFinished
  ) => CreateGeodataFinished | DeleteGeodataFinished | ModifyGeodataFinished | null
): CreateGeodataFinished | DeleteGeodataFinished | ModifyGeodataFinished | null {
  switch (EventType[type]) {
    case 'NONE':
      return null
    case 'CreateGeodataFinished':
      return accessor(new CreateGeodataFinished())! as CreateGeodataFinished
    case 'ModifyGeodataFinished':
      return accessor(new ModifyGeodataFinished())! as ModifyGeodataFinished
    case 'DeleteGeodataFinished':
      return accessor(new DeleteGeodataFinished())! as DeleteGeodataFinished
    default:
      return null
  }
}

export function unionListToEventType(
  type: EventType,
  accessor: (
    index: number,
    obj: CreateGeodataFinished | DeleteGeodataFinished | ModifyGeodataFinished
  ) => CreateGeodataFinished | DeleteGeodataFinished | ModifyGeodataFinished | null,
  index: number
): CreateGeodataFinished | DeleteGeodataFinished | ModifyGeodataFinished | null {
  switch (EventType[type]) {
    case 'NONE':
      return null
    case 'CreateGeodataFinished':
      return accessor(index, new CreateGeodataFinished())! as CreateGeodataFinished
    case 'ModifyGeodataFinished':
      return accessor(index, new ModifyGeodataFinished())! as ModifyGeodataFinished
    case 'DeleteGeodataFinished':
      return accessor(index, new DeleteGeodataFinished())! as DeleteGeodataFinished
    default:
      return null
  }
}

export enum QueryType {
  NONE = 0,
  GetVersion = 1,
  CreateSound = 2,
  ModifySound = 3,
  DeleteSound = 4,
  SelectAllSound = 5,
  CreateGeodata = 6,
  ModifyGeodata = 7,
  DeleteGeodata = 8,
  SelectAllGeodata = 9
}

export function unionToQueryType(
  type: QueryType,
  accessor: (
    obj:
      | CreateGeodata
      | CreateSound
      | DeleteGeodata
      | DeleteSound
      | GetVersion
      | ModifyGeodata
      | ModifySound
      | SelectAllGeodata
      | SelectAllSound
  ) =>
    | CreateGeodata
    | CreateSound
    | DeleteGeodata
    | DeleteSound
    | GetVersion
    | ModifyGeodata
    | ModifySound
    | SelectAllGeodata
    | SelectAllSound
    | null
):
  | CreateGeodata
  | CreateSound
  | DeleteGeodata
  | DeleteSound
  | GetVersion
  | ModifyGeodata
  | ModifySound
  | SelectAllGeodata
  | SelectAllSound
  | null {
  switch (QueryType[type]) {
    case 'NONE':
      return null
    case 'GetVersion':
      return accessor(new GetVersion())! as GetVersion
    case 'CreateSound':
      return accessor(new CreateSound())! as CreateSound
    case 'ModifySound':
      return accessor(new ModifySound())! as ModifySound
    case 'DeleteSound':
      return accessor(new DeleteSound())! as DeleteSound
    case 'SelectAllSound':
      return accessor(new SelectAllSound())! as SelectAllSound
    case 'CreateGeodata':
      return accessor(new CreateGeodata())! as CreateGeodata
    case 'ModifyGeodata':
      return accessor(new ModifyGeodata())! as ModifyGeodata
    case 'DeleteGeodata':
      return accessor(new DeleteGeodata())! as DeleteGeodata
    case 'SelectAllGeodata':
      return accessor(new SelectAllGeodata())! as SelectAllGeodata
    default:
      return null
  }
}

export function unionListToQueryType(
  type: QueryType,
  accessor: (
    index: number,
    obj:
      | CreateGeodata
      | CreateSound
      | DeleteGeodata
      | DeleteSound
      | GetVersion
      | ModifyGeodata
      | ModifySound
      | SelectAllGeodata
      | SelectAllSound
  ) =>
    | CreateGeodata
    | CreateSound
    | DeleteGeodata
    | DeleteSound
    | GetVersion
    | ModifyGeodata
    | ModifySound
    | SelectAllGeodata
    | SelectAllSound
    | null,
  index: number
):
  | CreateGeodata
  | CreateSound
  | DeleteGeodata
  | DeleteSound
  | GetVersion
  | ModifyGeodata
  | ModifySound
  | SelectAllGeodata
  | SelectAllSound
  | null {
  switch (QueryType[type]) {
    case 'NONE':
      return null
    case 'GetVersion':
      return accessor(index, new GetVersion())! as GetVersion
    case 'CreateSound':
      return accessor(index, new CreateSound())! as CreateSound
    case 'ModifySound':
      return accessor(index, new ModifySound())! as ModifySound
    case 'DeleteSound':
      return accessor(index, new DeleteSound())! as DeleteSound
    case 'SelectAllSound':
      return accessor(index, new SelectAllSound())! as SelectAllSound
    case 'CreateGeodata':
      return accessor(index, new CreateGeodata())! as CreateGeodata
    case 'ModifyGeodata':
      return accessor(index, new ModifyGeodata())! as ModifyGeodata
    case 'DeleteGeodata':
      return accessor(index, new DeleteGeodata())! as DeleteGeodata
    case 'SelectAllGeodata':
      return accessor(index, new SelectAllGeodata())! as SelectAllGeodata
    default:
      return null
  }
}

export enum QueryResultType {
  NONE = 0,
  VersionInfo = 1,
  DBCommandResult = 2,
  SoundAll = 3,
  GeodataALL = 4
}

export function unionToQueryResultType(
  type: QueryResultType,
  accessor: (
    obj: DBCommandResult | GeodataALL | SoundAll | VersionInfo
  ) => DBCommandResult | GeodataALL | SoundAll | VersionInfo | null
): DBCommandResult | GeodataALL | SoundAll | VersionInfo | null {
  switch (QueryResultType[type]) {
    case 'NONE':
      return null
    case 'VersionInfo':
      return accessor(new VersionInfo())! as VersionInfo
    case 'DBCommandResult':
      return accessor(new DBCommandResult())! as DBCommandResult
    case 'SoundAll':
      return accessor(new SoundAll())! as SoundAll
    case 'GeodataALL':
      return accessor(new GeodataALL())! as GeodataALL
    default:
      return null
  }
}

export function unionListToQueryResultType(
  type: QueryResultType,
  accessor: (
    index: number,
    obj: DBCommandResult | GeodataALL | SoundAll | VersionInfo
  ) => DBCommandResult | GeodataALL | SoundAll | VersionInfo | null,
  index: number
): DBCommandResult | GeodataALL | SoundAll | VersionInfo | null {
  switch (QueryResultType[type]) {
    case 'NONE':
      return null
    case 'VersionInfo':
      return accessor(index, new VersionInfo())! as VersionInfo
    case 'DBCommandResult':
      return accessor(index, new DBCommandResult())! as DBCommandResult
    case 'SoundAll':
      return accessor(index, new SoundAll())! as SoundAll
    case 'GeodataALL':
      return accessor(index, new GeodataALL())! as GeodataALL
    default:
      return null
  }
}

export enum ResultCode {
  OK = 0,
  ERROR = 1,
  NOTEXIST = 2,
  NOTAVIABLE = 3
}

export enum DBCommand {
  CreateSound = 0,
  ModifySound = 1,
  DeleteSound = 2,
  CreateGeodata = 3,
  ModifyGeodata = 4,
  DeleteGeodata = 5
}

export enum ActiveData {
  Active = 0,
  Inactive = 1,
  Both = 2
}

export enum MessageType {
  NONE = 0,
  Query = 1,
  QueryResult = 2,
  Event = 3
}

export function unionToMessageType(
  type: MessageType,
  accessor: (obj: Event | Query | QueryResult) => Event | Query | QueryResult | null
): Event | Query | QueryResult | null {
  switch (MessageType[type]) {
    case 'NONE':
      return null
    case 'Query':
      return accessor(new Query())! as Query
    case 'QueryResult':
      return accessor(new QueryResult())! as QueryResult
    case 'Event':
      return accessor(new Event())! as Event
    default:
      return null
  }
}

export function unionListToMessageType(
  type: MessageType,
  accessor: (index: number, obj: Event | Query | QueryResult) => Event | Query | QueryResult | null,
  index: number
): Event | Query | QueryResult | null {
  switch (MessageType[type]) {
    case 'NONE':
      return null
    case 'Query':
      return accessor(index, new Query())! as Query
    case 'QueryResult':
      return accessor(index, new QueryResult())! as QueryResult
    case 'Event':
      return accessor(index, new Event())! as Event
    default:
      return null
  }
}

/**
 *querys
 */
export class CreateGeodataFinished
  implements flatbuffers.IUnpackableObject<CreateGeodataFinishedT>
{
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): CreateGeodataFinished {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsCreateGeodataFinished(
    bb: flatbuffers.ByteBuffer,
    obj?: CreateGeodataFinished
  ): CreateGeodataFinished {
    return (obj || new CreateGeodataFinished()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsCreateGeodataFinished(
    bb: flatbuffers.ByteBuffer,
    obj?: CreateGeodataFinished
  ): CreateGeodataFinished {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new CreateGeodataFinished()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  id(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0
  }

  geodata(): string | null
  geodata(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  geodata(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  static startCreateGeodataFinished(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  static addId(builder: flatbuffers.Builder, id: number) {
    builder.addFieldInt32(0, id, 0)
  }

  static addGeodata(builder: flatbuffers.Builder, geodataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, geodataOffset, 0)
  }

  static endCreateGeodataFinished(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createCreateGeodataFinished(
    builder: flatbuffers.Builder,
    id: number,
    geodataOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    CreateGeodataFinished.startCreateGeodataFinished(builder)
    CreateGeodataFinished.addId(builder, id)
    CreateGeodataFinished.addGeodata(builder, geodataOffset)
    return CreateGeodataFinished.endCreateGeodataFinished(builder)
  }

  unpack(): CreateGeodataFinishedT {
    return new CreateGeodataFinishedT(this.id(), this.geodata())
  }

  unpackTo(_o: CreateGeodataFinishedT): void {
    _o.id = this.id()
    _o.geodata = this.geodata()
  }
}

export class CreateGeodataFinishedT implements flatbuffers.IGeneratedObject {
  constructor(public id: number = 0, public geodata: string | Uint8Array | null = null) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const geodata = this.geodata !== null ? builder.createString(this.geodata!) : 0

    return CreateGeodataFinished.createCreateGeodataFinished(builder, this.id, geodata)
  }
}

export class ModifyGeodataFinished
  implements flatbuffers.IUnpackableObject<ModifyGeodataFinishedT>
{
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): ModifyGeodataFinished {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsModifyGeodataFinished(
    bb: flatbuffers.ByteBuffer,
    obj?: ModifyGeodataFinished
  ): ModifyGeodataFinished {
    return (obj || new ModifyGeodataFinished()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsModifyGeodataFinished(
    bb: flatbuffers.ByteBuffer,
    obj?: ModifyGeodataFinished
  ): ModifyGeodataFinished {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new ModifyGeodataFinished()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  id(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0
  }

  geodata(): string | null
  geodata(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  geodata(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  static startModifyGeodataFinished(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  static addId(builder: flatbuffers.Builder, id: number) {
    builder.addFieldInt32(0, id, 0)
  }

  static addGeodata(builder: flatbuffers.Builder, geodataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, geodataOffset, 0)
  }

  static endModifyGeodataFinished(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createModifyGeodataFinished(
    builder: flatbuffers.Builder,
    id: number,
    geodataOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    ModifyGeodataFinished.startModifyGeodataFinished(builder)
    ModifyGeodataFinished.addId(builder, id)
    ModifyGeodataFinished.addGeodata(builder, geodataOffset)
    return ModifyGeodataFinished.endModifyGeodataFinished(builder)
  }

  unpack(): ModifyGeodataFinishedT {
    return new ModifyGeodataFinishedT(this.id(), this.geodata())
  }

  unpackTo(_o: ModifyGeodataFinishedT): void {
    _o.id = this.id()
    _o.geodata = this.geodata()
  }
}

export class ModifyGeodataFinishedT implements flatbuffers.IGeneratedObject {
  constructor(public id: number = 0, public geodata: string | Uint8Array | null = null) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const geodata = this.geodata !== null ? builder.createString(this.geodata!) : 0

    return ModifyGeodataFinished.createModifyGeodataFinished(builder, this.id, geodata)
  }
}

export class DeleteGeodataFinished
  implements flatbuffers.IUnpackableObject<DeleteGeodataFinishedT>
{
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): DeleteGeodataFinished {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsDeleteGeodataFinished(
    bb: flatbuffers.ByteBuffer,
    obj?: DeleteGeodataFinished
  ): DeleteGeodataFinished {
    return (obj || new DeleteGeodataFinished()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsDeleteGeodataFinished(
    bb: flatbuffers.ByteBuffer,
    obj?: DeleteGeodataFinished
  ): DeleteGeodataFinished {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new DeleteGeodataFinished()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  id(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0
  }

  static startDeleteGeodataFinished(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addId(builder: flatbuffers.Builder, id: number) {
    builder.addFieldInt32(0, id, 0)
  }

  static endDeleteGeodataFinished(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createDeleteGeodataFinished(builder: flatbuffers.Builder, id: number): flatbuffers.Offset {
    DeleteGeodataFinished.startDeleteGeodataFinished(builder)
    DeleteGeodataFinished.addId(builder, id)
    return DeleteGeodataFinished.endDeleteGeodataFinished(builder)
  }

  unpack(): DeleteGeodataFinishedT {
    return new DeleteGeodataFinishedT(this.id())
  }

  unpackTo(_o: DeleteGeodataFinishedT): void {
    _o.id = this.id()
  }
}

export class DeleteGeodataFinishedT implements flatbuffers.IGeneratedObject {
  constructor(public id: number = 0) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return DeleteGeodataFinished.createDeleteGeodataFinished(builder, this.id)
  }
}

export class Event implements flatbuffers.IUnpackableObject<EventT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Event {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsEvent(bb: flatbuffers.ByteBuffer, obj?: Event): Event {
    return (obj || new Event()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsEvent(bb: flatbuffers.ByteBuffer, obj?: Event): Event {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Event()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  typeOfEventType(): EventType {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : EventType.NONE
  }

  typeOfEvent(obj: any): any | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static startEvent(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addTypeOfEventType(builder: flatbuffers.Builder, typeOfEventType: EventType) {
    builder.addFieldInt8(0, typeOfEventType, EventType.NONE)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addTypeOfEvent(builder: flatbuffers.Builder, typeOfEventOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, typeOfEventOffset, 0)
  }

  static endEvent(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    builder.requiredField(offset, 6) // type_of_event
    return offset
  }

  static createEvent(
    builder: flatbuffers.Builder,
    typeOfEventType: EventType,
    typeOfEventOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    Event.startEvent(builder)
    Event.addTypeOfEventType(builder, typeOfEventType)
    Event.addTypeOfEvent(builder, typeOfEventOffset)
    return Event.endEvent(builder)
  }

  unpack(): EventT {
    return new EventT(
      this.typeOfEventType(),
      // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
      (() => {
        const temp = unionToEventType(this.typeOfEventType(), this.typeOfEvent.bind(this))
        if (temp === null) {
          return null
        }
        return temp.unpack()
      })()
    )
  }

  unpackTo(_o: EventT): void {
    _o.typeOfEventType = this.typeOfEventType()
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    _o.typeOfEvent = (() => {
      const temp = unionToEventType(this.typeOfEventType(), this.typeOfEvent.bind(this))
      if (temp === null) {
        return null
      }
      return temp.unpack()
    })()
  }
}

export class EventT implements flatbuffers.IGeneratedObject {
  constructor(
    public typeOfEventType: EventType = EventType.NONE,
    public typeOfEvent:
      | CreateGeodataFinishedT
      | DeleteGeodataFinishedT
      | ModifyGeodataFinishedT
      | null = null
  ) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const typeOfEvent = builder.createObjectOffset(this.typeOfEvent)

    return Event.createEvent(builder, this.typeOfEventType, typeOfEvent)
  }
}

export class Query implements flatbuffers.IUnpackableObject<QueryT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Query {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsQuery(bb: flatbuffers.ByteBuffer, obj?: Query): Query {
    return (obj || new Query()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsQuery(bb: flatbuffers.ByteBuffer, obj?: Query): Query {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Query()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  typeOfQueryType(): QueryType {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : QueryType.NONE
  }

  typeOfQuery(obj: any): any | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static startQuery(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addTypeOfQueryType(builder: flatbuffers.Builder, typeOfQueryType: QueryType) {
    builder.addFieldInt8(0, typeOfQueryType, QueryType.NONE)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addTypeOfQuery(builder: flatbuffers.Builder, typeOfQueryOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, typeOfQueryOffset, 0)
  }

  static endQuery(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    builder.requiredField(offset, 6) // type_of_query
    return offset
  }

  static createQuery(
    builder: flatbuffers.Builder,
    typeOfQueryType: QueryType,
    typeOfQueryOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    Query.startQuery(builder)
    Query.addTypeOfQueryType(builder, typeOfQueryType)
    Query.addTypeOfQuery(builder, typeOfQueryOffset)
    return Query.endQuery(builder)
  }

  unpack(): QueryT {
    return new QueryT(
      this.typeOfQueryType(),
      // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
      (() => {
        const temp = unionToQueryType(this.typeOfQueryType(), this.typeOfQuery.bind(this))
        if (temp === null) {
          return null
        }
        return temp.unpack()
      })()
    )
  }

  unpackTo(_o: QueryT): void {
    _o.typeOfQueryType = this.typeOfQueryType()
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    _o.typeOfQuery = (() => {
      const temp = unionToQueryType(this.typeOfQueryType(), this.typeOfQuery.bind(this))
      if (temp === null) {
        return null
      }
      return temp.unpack()
    })()
  }
}

export class QueryT implements flatbuffers.IGeneratedObject {
  constructor(
    public typeOfQueryType: QueryType = QueryType.NONE,
    public typeOfQuery:
      | CreateGeodataT
      | CreateSoundT
      | DeleteGeodataT
      | DeleteSoundT
      | GetVersionT
      | ModifyGeodataT
      | ModifySoundT
      | SelectAllGeodataT
      | SelectAllSoundT
      | null = null
  ) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const typeOfQuery = builder.createObjectOffset(this.typeOfQuery)

    return Query.createQuery(builder, this.typeOfQueryType, typeOfQuery)
  }
}

export class QueryResult implements flatbuffers.IUnpackableObject<QueryResultT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): QueryResult {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsQueryResult(bb: flatbuffers.ByteBuffer, obj?: QueryResult): QueryResult {
    return (obj || new QueryResult()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsQueryResult(
    bb: flatbuffers.ByteBuffer,
    obj?: QueryResult
  ): QueryResult {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new QueryResult()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  typeOfResult(): ResultCode {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ResultCode.OK
  }

  errortext(): string | null
  errortext(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  errortext(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  typeOfQueryType(): QueryResultType {
    const offset = this.bb!.__offset(this.bb_pos, 8)
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : QueryResultType.NONE
  }

  typeOfQuery(obj: any): any | null {
    const offset = this.bb!.__offset(this.bb_pos, 10)
    return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static startQueryResult(builder: flatbuffers.Builder) {
    builder.startObject(4)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addTypeOfResult(builder: flatbuffers.Builder, typeOfResult: ResultCode) {
    builder.addFieldInt8(0, typeOfResult, ResultCode.OK)
  }

  static addErrortext(builder: flatbuffers.Builder, errortextOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, errortextOffset, 0)
  }

  static addTypeOfQueryType(builder: flatbuffers.Builder, typeOfQueryType: QueryResultType) {
    builder.addFieldInt8(2, typeOfQueryType, QueryResultType.NONE)
  }

  static addTypeOfQuery(builder: flatbuffers.Builder, typeOfQueryOffset: flatbuffers.Offset) {
    builder.addFieldOffset(3, typeOfQueryOffset, 0)
  }

  static endQueryResult(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createQueryResult(
    builder: flatbuffers.Builder,
    typeOfResult: ResultCode,
    errortextOffset: flatbuffers.Offset,
    typeOfQueryType: QueryResultType,
    typeOfQueryOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    QueryResult.startQueryResult(builder)
    QueryResult.addTypeOfResult(builder, typeOfResult)
    QueryResult.addErrortext(builder, errortextOffset)
    QueryResult.addTypeOfQueryType(builder, typeOfQueryType)
    QueryResult.addTypeOfQuery(builder, typeOfQueryOffset)
    return QueryResult.endQueryResult(builder)
  }

  unpack(): QueryResultT {
    return new QueryResultT(
      this.typeOfResult(),
      this.errortext(),
      this.typeOfQueryType(),
      (() => {
        const temp = unionToQueryResultType(this.typeOfQueryType(), this.typeOfQuery.bind(this))
        if (temp === null) {
          return null
        }
        return temp.unpack()
      })()
    )
  }

  unpackTo(_o: QueryResultT): void {
    _o.typeOfResult = this.typeOfResult()
    _o.errortext = this.errortext()
    _o.typeOfQueryType = this.typeOfQueryType()
    _o.typeOfQuery = (() => {
      const temp = unionToQueryResultType(this.typeOfQueryType(), this.typeOfQuery.bind(this))
      if (temp === null) {
        return null
      }
      return temp.unpack()
    })()
  }
}

export class QueryResultT implements flatbuffers.IGeneratedObject {
  constructor(
    public typeOfResult: ResultCode = ResultCode.OK,
    public errortext: string | Uint8Array | null = null,
    public typeOfQueryType: QueryResultType = QueryResultType.NONE,
    public typeOfQuery: DBCommandResultT | GeodataALLT | SoundAllT | VersionInfoT | null = null
  ) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const errortext = this.errortext !== null ? builder.createString(this.errortext!) : 0
    const typeOfQuery = builder.createObjectOffset(this.typeOfQuery)

    return QueryResult.createQueryResult(
      builder,
      this.typeOfResult,
      errortext,
      this.typeOfQueryType,
      typeOfQuery
    )
  }
}

export class SoundAll implements flatbuffers.IUnpackableObject<SoundAllT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): SoundAll {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsSoundAll(bb: flatbuffers.ByteBuffer, obj?: SoundAll): SoundAll {
    return (obj || new SoundAll()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsSoundAll(bb: flatbuffers.ByteBuffer, obj?: SoundAll): SoundAll {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new SoundAll()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  listofdata(index: number, obj?: Sound): Sound | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? (obj || new Sound()).__init(
          this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),
          this.bb!
        )
      : null
  }

  listofdataLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0
  }

  static startSoundAll(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addListofdata(builder: flatbuffers.Builder, listofdataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, listofdataOffset, 0)
  }

  static createListofdataVector(
    builder: flatbuffers.Builder,
    data: flatbuffers.Offset[]
  ): flatbuffers.Offset {
    builder.startVector(4, data.length, 4)
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!)
    }
    return builder.endVector()
  }

  static startListofdataVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4)
  }

  static endSoundAll(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    builder.requiredField(offset, 4) // listofdata
    return offset
  }

  static createSoundAll(
    builder: flatbuffers.Builder,
    listofdataOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    SoundAll.startSoundAll(builder)
    SoundAll.addListofdata(builder, listofdataOffset)
    return SoundAll.endSoundAll(builder)
  }

  unpack(): SoundAllT {
    return new SoundAllT(
      this.bb!.createObjList<Sound, SoundT>(this.listofdata.bind(this), this.listofdataLength())
    )
  }

  unpackTo(_o: SoundAllT): void {
    _o.listofdata = this.bb!.createObjList<Sound, SoundT>(
      this.listofdata.bind(this),
      this.listofdataLength()
    )
  }
}

export class SoundAllT implements flatbuffers.IGeneratedObject {
  constructor(public listofdata: SoundT[] = []) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const listofdata = SoundAll.createListofdataVector(
      builder,
      builder.createObjectOffsetList(this.listofdata)
    )

    return SoundAll.createSoundAll(builder, listofdata)
  }
}

export class Sound implements flatbuffers.IUnpackableObject<SoundT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Sound {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsSound(bb: flatbuffers.ByteBuffer, obj?: Sound): Sound {
    return (obj || new Sound()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsSound(bb: flatbuffers.ByteBuffer, obj?: Sound): Sound {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Sound()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  id(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0
  }

  name(): string | null
  name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  name(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  extension(): string | null
  extension(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  extension(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 8)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  isDefault(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 10)
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false
  }

  data(index: number): number | null {
    const offset = this.bb!.__offset(this.bb_pos, 12)
    return offset ? this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : 0
  }

  dataLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 12)
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0
  }

  dataArray(): Int8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 12)
    return offset
      ? new Int8Array(
          this.bb!.bytes().buffer,
          this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
          this.bb!.__vector_len(this.bb_pos + offset)
        )
      : null
  }

  static startSound(builder: flatbuffers.Builder) {
    builder.startObject(5)
  }

  static addId(builder: flatbuffers.Builder, id: number) {
    builder.addFieldInt32(0, id, 0)
  }

  static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, nameOffset, 0)
  }

  static addExtension(builder: flatbuffers.Builder, extensionOffset: flatbuffers.Offset) {
    builder.addFieldOffset(2, extensionOffset, 0)
  }

  static addIsDefault(builder: flatbuffers.Builder, isDefault: boolean) {
    builder.addFieldInt8(3, +isDefault, +false)
  }

  static addData(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(4, dataOffset, 0)
  }

  static createDataVector(
    builder: flatbuffers.Builder,
    data: number[] | Int8Array
  ): flatbuffers.Offset
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createDataVector(
    builder: flatbuffers.Builder,
    data: number[] | Uint8Array
  ): flatbuffers.Offset
  static createDataVector(
    builder: flatbuffers.Builder,
    data: number[] | Int8Array | Uint8Array
  ): flatbuffers.Offset {
    builder.startVector(1, data.length, 1)
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt8(data[i]!)
    }
    return builder.endVector()
  }

  static startDataVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(1, numElems, 1)
  }

  static endSound(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createSound(
    builder: flatbuffers.Builder,
    id: number,
    nameOffset: flatbuffers.Offset,
    extensionOffset: flatbuffers.Offset,
    isDefault: boolean,
    dataOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    Sound.startSound(builder)
    Sound.addId(builder, id)
    Sound.addName(builder, nameOffset)
    Sound.addExtension(builder, extensionOffset)
    Sound.addIsDefault(builder, isDefault)
    Sound.addData(builder, dataOffset)
    return Sound.endSound(builder)
  }

  unpack(): SoundT {
    return new SoundT(
      this.id(),
      this.name(),
      this.extension(),
      this.isDefault(),
      this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength())
    )
  }

  unpackTo(_o: SoundT): void {
    _o.id = this.id()
    _o.name = this.name()
    _o.extension = this.extension()
    _o.isDefault = this.isDefault()
    _o.data = this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength())
  }
}

export class SoundT implements flatbuffers.IGeneratedObject {
  constructor(
    public id: number = 0,
    public name: string | Uint8Array | null = null,
    public extension: string | Uint8Array | null = null,
    public isDefault: boolean = false,
    public data: number[] = []
  ) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const name = this.name !== null ? builder.createString(this.name!) : 0
    const extension = this.extension !== null ? builder.createString(this.extension!) : 0
    const data = Sound.createDataVector(builder, this.data)

    return Sound.createSound(builder, this.id, name, extension, this.isDefault, data)
  }
}

export class GeodataALL implements flatbuffers.IUnpackableObject<GeodataALLT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): GeodataALL {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsGeodataALL(bb: flatbuffers.ByteBuffer, obj?: GeodataALL): GeodataALL {
    return (obj || new GeodataALL()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsGeodataALL(bb: flatbuffers.ByteBuffer, obj?: GeodataALL): GeodataALL {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new GeodataALL()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  listofdata(index: number, obj?: Geodata): Geodata | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? (obj || new Geodata()).__init(
          this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),
          this.bb!
        )
      : null
  }

  listofdataLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0
  }

  static startGeodataALL(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addListofdata(builder: flatbuffers.Builder, listofdataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, listofdataOffset, 0)
  }

  static createListofdataVector(
    builder: flatbuffers.Builder,
    data: flatbuffers.Offset[]
  ): flatbuffers.Offset {
    builder.startVector(4, data.length, 4)
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!)
    }
    return builder.endVector()
  }

  static startListofdataVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4)
  }

  static endGeodataALL(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    builder.requiredField(offset, 4) // listofdata
    return offset
  }

  static createGeodataALL(
    builder: flatbuffers.Builder,
    listofdataOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    GeodataALL.startGeodataALL(builder)
    GeodataALL.addListofdata(builder, listofdataOffset)
    return GeodataALL.endGeodataALL(builder)
  }

  unpack(): GeodataALLT {
    return new GeodataALLT(
      this.bb!.createObjList<Geodata, GeodataT>(this.listofdata.bind(this), this.listofdataLength())
    )
  }

  unpackTo(_o: GeodataALLT): void {
    _o.listofdata = this.bb!.createObjList<Geodata, GeodataT>(
      this.listofdata.bind(this),
      this.listofdataLength()
    )
  }
}

export class GeodataALLT implements flatbuffers.IGeneratedObject {
  constructor(public listofdata: GeodataT[] = []) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const listofdata = GeodataALL.createListofdataVector(
      builder,
      builder.createObjectOffsetList(this.listofdata)
    )

    return GeodataALL.createGeodataALL(builder, listofdata)
  }
}

export class Geodata implements flatbuffers.IUnpackableObject<GeodataT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Geodata {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsGeodata(bb: flatbuffers.ByteBuffer, obj?: Geodata): Geodata {
    return (obj || new Geodata()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsGeodata(bb: flatbuffers.ByteBuffer, obj?: Geodata): Geodata {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Geodata()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  id(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0
  }

  geodata(): string | null
  geodata(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  geodata(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  static startGeodata(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  static addId(builder: flatbuffers.Builder, id: number) {
    builder.addFieldInt32(0, id, 0)
  }

  static addGeodata(builder: flatbuffers.Builder, geodataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, geodataOffset, 0)
  }

  static endGeodata(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createGeodata(
    builder: flatbuffers.Builder,
    id: number,
    geodataOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    Geodata.startGeodata(builder)
    Geodata.addId(builder, id)
    Geodata.addGeodata(builder, geodataOffset)
    return Geodata.endGeodata(builder)
  }

  unpack(): GeodataT {
    return new GeodataT(this.id(), this.geodata())
  }

  unpackTo(_o: GeodataT): void {
    _o.id = this.id()
    _o.geodata = this.geodata()
  }
}

export class GeodataT implements flatbuffers.IGeneratedObject {
  constructor(public id: number = 0, public geodata: string | Uint8Array | null = null) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const geodata = this.geodata !== null ? builder.createString(this.geodata!) : 0

    return Geodata.createGeodata(builder, this.id, geodata)
  }
}

export class VersionInfo implements flatbuffers.IUnpackableObject<VersionInfoT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): VersionInfo {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsVersionInfo(bb: flatbuffers.ByteBuffer, obj?: VersionInfo): VersionInfo {
    return (obj || new VersionInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsVersionInfo(
    bb: flatbuffers.ByteBuffer,
    obj?: VersionInfo
  ): VersionInfo {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new VersionInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  version(): string | null
  version(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  version(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  static startVersionInfo(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addVersion(builder: flatbuffers.Builder, versionOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, versionOffset, 0)
  }

  static endVersionInfo(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createVersionInfo(
    builder: flatbuffers.Builder,
    versionOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    VersionInfo.startVersionInfo(builder)
    VersionInfo.addVersion(builder, versionOffset)
    return VersionInfo.endVersionInfo(builder)
  }

  unpack(): VersionInfoT {
    return new VersionInfoT(this.version())
  }

  unpackTo(_o: VersionInfoT): void {
    _o.version = this.version()
  }
}

export class VersionInfoT implements flatbuffers.IGeneratedObject {
  constructor(public version: string | Uint8Array | null = null) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const version = this.version !== null ? builder.createString(this.version!) : 0

    return VersionInfo.createVersionInfo(builder, version)
  }
}

export class GetVersion implements flatbuffers.IUnpackableObject<GetVersionT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): GetVersion {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsGetVersion(bb: flatbuffers.ByteBuffer, obj?: GetVersion): GetVersion {
    return (obj || new GetVersion()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsGetVersion(bb: flatbuffers.ByteBuffer, obj?: GetVersion): GetVersion {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new GetVersion()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static startGetVersion(builder: flatbuffers.Builder) {
    builder.startObject(0)
  }

  static endGetVersion(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createGetVersion(builder: flatbuffers.Builder): flatbuffers.Offset {
    GetVersion.startGetVersion(builder)
    return GetVersion.endGetVersion(builder)
  }

  unpack(): GetVersionT {
    return new GetVersionT()
  }

  unpackTo(_o: GetVersionT): void {}
}

export class GetVersionT implements flatbuffers.IGeneratedObject {
  constructor() {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return GetVersion.createGetVersion(builder)
  }
}

export class CreateGeodata implements flatbuffers.IUnpackableObject<CreateGeodataT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): CreateGeodata {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsCreateGeodata(bb: flatbuffers.ByteBuffer, obj?: CreateGeodata): CreateGeodata {
    return (obj || new CreateGeodata()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsCreateGeodata(
    bb: flatbuffers.ByteBuffer,
    obj?: CreateGeodata
  ): CreateGeodata {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new CreateGeodata()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  geodata(): string | null
  geodata(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  geodata(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  static startCreateGeodata(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addGeodata(builder: flatbuffers.Builder, geodataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, geodataOffset, 0)
  }

  static endCreateGeodata(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createCreateGeodata(
    builder: flatbuffers.Builder,
    geodataOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    CreateGeodata.startCreateGeodata(builder)
    CreateGeodata.addGeodata(builder, geodataOffset)
    return CreateGeodata.endCreateGeodata(builder)
  }

  unpack(): CreateGeodataT {
    return new CreateGeodataT(this.geodata())
  }

  unpackTo(_o: CreateGeodataT): void {
    _o.geodata = this.geodata()
  }
}

export class CreateGeodataT implements flatbuffers.IGeneratedObject {
  constructor(public geodata: string | Uint8Array | null = null) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const geodata = this.geodata !== null ? builder.createString(this.geodata!) : 0

    return CreateGeodata.createCreateGeodata(builder, geodata)
  }
}

export class ModifyGeodata implements flatbuffers.IUnpackableObject<ModifyGeodataT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): ModifyGeodata {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsModifyGeodata(bb: flatbuffers.ByteBuffer, obj?: ModifyGeodata): ModifyGeodata {
    return (obj || new ModifyGeodata()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsModifyGeodata(
    bb: flatbuffers.ByteBuffer,
    obj?: ModifyGeodata
  ): ModifyGeodata {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new ModifyGeodata()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  id(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0
  }

  geodata(): string | null
  geodata(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  geodata(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  static startModifyGeodata(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  static addId(builder: flatbuffers.Builder, id: number) {
    builder.addFieldInt32(0, id, 0)
  }

  static addGeodata(builder: flatbuffers.Builder, geodataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, geodataOffset, 0)
  }

  static endModifyGeodata(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createModifyGeodata(
    builder: flatbuffers.Builder,
    id: number,
    geodataOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    ModifyGeodata.startModifyGeodata(builder)
    ModifyGeodata.addId(builder, id)
    ModifyGeodata.addGeodata(builder, geodataOffset)
    return ModifyGeodata.endModifyGeodata(builder)
  }

  unpack(): ModifyGeodataT {
    return new ModifyGeodataT(this.id(), this.geodata())
  }

  unpackTo(_o: ModifyGeodataT): void {
    _o.id = this.id()
    _o.geodata = this.geodata()
  }
}

export class ModifyGeodataT implements flatbuffers.IGeneratedObject {
  constructor(public id: number = 0, public geodata: string | Uint8Array | null = null) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const geodata = this.geodata !== null ? builder.createString(this.geodata!) : 0

    return ModifyGeodata.createModifyGeodata(builder, this.id, geodata)
  }
}

export class DeleteGeodata implements flatbuffers.IUnpackableObject<DeleteGeodataT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): DeleteGeodata {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsDeleteGeodata(bb: flatbuffers.ByteBuffer, obj?: DeleteGeodata): DeleteGeodata {
    return (obj || new DeleteGeodata()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsDeleteGeodata(
    bb: flatbuffers.ByteBuffer,
    obj?: DeleteGeodata
  ): DeleteGeodata {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new DeleteGeodata()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  id(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0
  }

  static startDeleteGeodata(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addId(builder: flatbuffers.Builder, id: number) {
    builder.addFieldInt32(0, id, 0)
  }

  static endDeleteGeodata(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createDeleteGeodata(builder: flatbuffers.Builder, id: number): flatbuffers.Offset {
    DeleteGeodata.startDeleteGeodata(builder)
    DeleteGeodata.addId(builder, id)
    return DeleteGeodata.endDeleteGeodata(builder)
  }

  unpack(): DeleteGeodataT {
    return new DeleteGeodataT(this.id())
  }

  unpackTo(_o: DeleteGeodataT): void {
    _o.id = this.id()
  }
}

export class DeleteGeodataT implements flatbuffers.IGeneratedObject {
  constructor(public id: number = 0) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return DeleteGeodata.createDeleteGeodata(builder, this.id)
  }
}

export class SelectAllGeodata implements flatbuffers.IUnpackableObject<SelectAllGeodataT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): SelectAllGeodata {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsSelectAllGeodata(
    bb: flatbuffers.ByteBuffer,
    obj?: SelectAllGeodata
  ): SelectAllGeodata {
    return (obj || new SelectAllGeodata()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsSelectAllGeodata(
    bb: flatbuffers.ByteBuffer,
    obj?: SelectAllGeodata
  ): SelectAllGeodata {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new SelectAllGeodata()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  active(): ActiveData {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActiveData.Active
  }

  static startSelectAllGeodata(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addActive(builder: flatbuffers.Builder, active: ActiveData) {
    builder.addFieldInt8(0, active, ActiveData.Active)
  }

  static endSelectAllGeodata(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createSelectAllGeodata(
    builder: flatbuffers.Builder,
    active: ActiveData
  ): flatbuffers.Offset {
    SelectAllGeodata.startSelectAllGeodata(builder)
    SelectAllGeodata.addActive(builder, active)
    return SelectAllGeodata.endSelectAllGeodata(builder)
  }

  unpack(): SelectAllGeodataT {
    return new SelectAllGeodataT(this.active())
  }

  unpackTo(_o: SelectAllGeodataT): void {
    _o.active = this.active()
  }
}

export class SelectAllGeodataT implements flatbuffers.IGeneratedObject {
  constructor(public active: ActiveData = ActiveData.Active) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SelectAllGeodata.createSelectAllGeodata(builder, this.active)
  }
}

export class SelectAllSound implements flatbuffers.IUnpackableObject<SelectAllSoundT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): SelectAllSound {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsSelectAllSound(bb: flatbuffers.ByteBuffer, obj?: SelectAllSound): SelectAllSound {
    return (obj || new SelectAllSound()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsSelectAllSound(
    bb: flatbuffers.ByteBuffer,
    obj?: SelectAllSound
  ): SelectAllSound {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new SelectAllSound()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  withBinaryData(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false
  }

  static startSelectAllSound(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addWithBinaryData(builder: flatbuffers.Builder, withBinaryData: boolean) {
    builder.addFieldInt8(0, +withBinaryData, +false)
  }

  static endSelectAllSound(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createSelectAllSound(
    builder: flatbuffers.Builder,
    withBinaryData: boolean
  ): flatbuffers.Offset {
    SelectAllSound.startSelectAllSound(builder)
    SelectAllSound.addWithBinaryData(builder, withBinaryData)
    return SelectAllSound.endSelectAllSound(builder)
  }

  unpack(): SelectAllSoundT {
    return new SelectAllSoundT(this.withBinaryData())
  }

  unpackTo(_o: SelectAllSoundT): void {
    _o.withBinaryData = this.withBinaryData()
  }
}

export class SelectAllSoundT implements flatbuffers.IGeneratedObject {
  constructor(public withBinaryData: boolean = false) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SelectAllSound.createSelectAllSound(builder, this.withBinaryData)
  }
}

export class CreateSound implements flatbuffers.IUnpackableObject<CreateSoundT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): CreateSound {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsCreateSound(bb: flatbuffers.ByteBuffer, obj?: CreateSound): CreateSound {
    return (obj || new CreateSound()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsCreateSound(
    bb: flatbuffers.ByteBuffer,
    obj?: CreateSound
  ): CreateSound {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new CreateSound()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  name(): string | null
  name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  name(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  extension(): string | null
  extension(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  extension(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  data(index: number): number | null {
    const offset = this.bb!.__offset(this.bb_pos, 8)
    return offset ? this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : 0
  }

  dataLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8)
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0
  }

  dataArray(): Int8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 8)
    return offset
      ? new Int8Array(
          this.bb!.bytes().buffer,
          this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
          this.bb!.__vector_len(this.bb_pos + offset)
        )
      : null
  }

  static startCreateSound(builder: flatbuffers.Builder) {
    builder.startObject(3)
  }

  static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, nameOffset, 0)
  }

  static addExtension(builder: flatbuffers.Builder, extensionOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, extensionOffset, 0)
  }

  static addData(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(2, dataOffset, 0)
  }

  static createDataVector(
    builder: flatbuffers.Builder,
    data: number[] | Int8Array
  ): flatbuffers.Offset
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createDataVector(
    builder: flatbuffers.Builder,
    data: number[] | Uint8Array
  ): flatbuffers.Offset
  static createDataVector(
    builder: flatbuffers.Builder,
    data: number[] | Int8Array | Uint8Array
  ): flatbuffers.Offset {
    builder.startVector(1, data.length, 1)
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt8(data[i]!)
    }
    return builder.endVector()
  }

  static startDataVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(1, numElems, 1)
  }

  static endCreateSound(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createCreateSound(
    builder: flatbuffers.Builder,
    nameOffset: flatbuffers.Offset,
    extensionOffset: flatbuffers.Offset,
    dataOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    CreateSound.startCreateSound(builder)
    CreateSound.addName(builder, nameOffset)
    CreateSound.addExtension(builder, extensionOffset)
    CreateSound.addData(builder, dataOffset)
    return CreateSound.endCreateSound(builder)
  }

  unpack(): CreateSoundT {
    return new CreateSoundT(
      this.name(),
      this.extension(),
      this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength())
    )
  }

  unpackTo(_o: CreateSoundT): void {
    _o.name = this.name()
    _o.extension = this.extension()
    _o.data = this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength())
  }
}

export class CreateSoundT implements flatbuffers.IGeneratedObject {
  constructor(
    public name: string | Uint8Array | null = null,
    public extension: string | Uint8Array | null = null,
    public data: number[] = []
  ) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const name = this.name !== null ? builder.createString(this.name!) : 0
    const extension = this.extension !== null ? builder.createString(this.extension!) : 0
    const data = CreateSound.createDataVector(builder, this.data)

    return CreateSound.createCreateSound(builder, name, extension, data)
  }
}

export class ModifySound implements flatbuffers.IUnpackableObject<ModifySoundT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): ModifySound {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsModifySound(bb: flatbuffers.ByteBuffer, obj?: ModifySound): ModifySound {
    return (obj || new ModifySound()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsModifySound(
    bb: flatbuffers.ByteBuffer,
    obj?: ModifySound
  ): ModifySound {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new ModifySound()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  id(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0
  }

  name(): string | null
  name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  name(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  extension(): string | null
  extension(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  extension(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 8)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  data(index: number): number | null {
    const offset = this.bb!.__offset(this.bb_pos, 10)
    return offset ? this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : 0
  }

  dataLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 10)
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0
  }

  dataArray(): Int8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 10)
    return offset
      ? new Int8Array(
          this.bb!.bytes().buffer,
          this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
          this.bb!.__vector_len(this.bb_pos + offset)
        )
      : null
  }

  static startModifySound(builder: flatbuffers.Builder) {
    builder.startObject(4)
  }

  static addId(builder: flatbuffers.Builder, id: number) {
    builder.addFieldInt32(0, id, 0)
  }

  static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, nameOffset, 0)
  }

  static addExtension(builder: flatbuffers.Builder, extensionOffset: flatbuffers.Offset) {
    builder.addFieldOffset(2, extensionOffset, 0)
  }

  static addData(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(3, dataOffset, 0)
  }

  static createDataVector(
    builder: flatbuffers.Builder,
    data: number[] | Int8Array
  ): flatbuffers.Offset
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createDataVector(
    builder: flatbuffers.Builder,
    data: number[] | Uint8Array
  ): flatbuffers.Offset
  static createDataVector(
    builder: flatbuffers.Builder,
    data: number[] | Int8Array | Uint8Array
  ): flatbuffers.Offset {
    builder.startVector(1, data.length, 1)
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt8(data[i]!)
    }
    return builder.endVector()
  }

  static startDataVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(1, numElems, 1)
  }

  static endModifySound(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createModifySound(
    builder: flatbuffers.Builder,
    id: number,
    nameOffset: flatbuffers.Offset,
    extensionOffset: flatbuffers.Offset,
    dataOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    ModifySound.startModifySound(builder)
    ModifySound.addId(builder, id)
    ModifySound.addName(builder, nameOffset)
    ModifySound.addExtension(builder, extensionOffset)
    ModifySound.addData(builder, dataOffset)
    return ModifySound.endModifySound(builder)
  }

  unpack(): ModifySoundT {
    return new ModifySoundT(
      this.id(),
      this.name(),
      this.extension(),
      this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength())
    )
  }

  unpackTo(_o: ModifySoundT): void {
    _o.id = this.id()
    _o.name = this.name()
    _o.extension = this.extension()
    _o.data = this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength())
  }
}

export class ModifySoundT implements flatbuffers.IGeneratedObject {
  constructor(
    public id: number = 0,
    public name: string | Uint8Array | null = null,
    public extension: string | Uint8Array | null = null,
    public data: number[] = []
  ) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const name = this.name !== null ? builder.createString(this.name!) : 0
    const extension = this.extension !== null ? builder.createString(this.extension!) : 0
    const data = ModifySound.createDataVector(builder, this.data)

    return ModifySound.createModifySound(builder, this.id, name, extension, data)
  }
}

export class DeleteSound implements flatbuffers.IUnpackableObject<DeleteSoundT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): DeleteSound {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsDeleteSound(bb: flatbuffers.ByteBuffer, obj?: DeleteSound): DeleteSound {
    return (obj || new DeleteSound()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsDeleteSound(
    bb: flatbuffers.ByteBuffer,
    obj?: DeleteSound
  ): DeleteSound {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new DeleteSound()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  id(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static startDeleteSound(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addId(builder: flatbuffers.Builder, id: number) {
    builder.addFieldInt32(0, id, 0)
  }

  static endDeleteSound(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createDeleteSound(builder: flatbuffers.Builder, id: number): flatbuffers.Offset {
    DeleteSound.startDeleteSound(builder)
    DeleteSound.addId(builder, id)
    return DeleteSound.endDeleteSound(builder)
  }

  unpack(): DeleteSoundT {
    return new DeleteSoundT(this.id())
  }

  unpackTo(_o: DeleteSoundT): void {
    _o.id = this.id()
  }
}

export class DeleteSoundT implements flatbuffers.IGeneratedObject {
  constructor(public id: number = 0) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return DeleteSound.createDeleteSound(builder, this.id)
  }
}

export class DBCommandResult implements flatbuffers.IUnpackableObject<DBCommandResultT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): DBCommandResult {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsDBCommandResult(
    bb: flatbuffers.ByteBuffer,
    obj?: DBCommandResult
  ): DBCommandResult {
    return (obj || new DBCommandResult()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsDBCommandResult(
    bb: flatbuffers.ByteBuffer,
    obj?: DBCommandResult
  ): DBCommandResult {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new DBCommandResult()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  dbCommandName(): DBCommand {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : DBCommand.CreateSound
  }

  success(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false
  }

  id(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8)
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0
  }

  errortext(): string | null
  errortext(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  errortext(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 10)
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static startDBCommandResult(builder: flatbuffers.Builder) {
    builder.startObject(4)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addDbCommandName(builder: flatbuffers.Builder, dbCommandName: DBCommand) {
    builder.addFieldInt32(0, dbCommandName, DBCommand.CreateSound)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addSuccess(builder: flatbuffers.Builder, success: boolean) {
    builder.addFieldInt8(1, +success, +false)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addId(builder: flatbuffers.Builder, id: number) {
    builder.addFieldInt32(2, id, 0)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addErrortext(builder: flatbuffers.Builder, errortextOffset: flatbuffers.Offset) {
    builder.addFieldOffset(3, errortextOffset, 0)
  }

  static endDBCommandResult(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createDBCommandResult(
    builder: flatbuffers.Builder,
    dbCommandName: DBCommand,
    success: boolean,
    id: number,
    errortextOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    DBCommandResult.startDBCommandResult(builder)
    DBCommandResult.addDbCommandName(builder, dbCommandName)
    DBCommandResult.addSuccess(builder, success)
    DBCommandResult.addId(builder, id)
    DBCommandResult.addErrortext(builder, errortextOffset)
    return DBCommandResult.endDBCommandResult(builder)
  }

  unpack(): DBCommandResultT {
    return new DBCommandResultT(this.dbCommandName(), this.success(), this.id(), this.errortext())
  }

  unpackTo(_o: DBCommandResultT): void {
    _o.dbCommandName = this.dbCommandName()
    _o.success = this.success()
    _o.id = this.id()
    _o.errortext = this.errortext()
  }
}

export class DBCommandResultT implements flatbuffers.IGeneratedObject {
  constructor(
    public dbCommandName: DBCommand = DBCommand.CreateSound,
    public success: boolean = false,
    public id: number = 0,
    public errortext: string | Uint8Array | null = null
  ) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const errortext = this.errortext !== null ? builder.createString(this.errortext!) : 0

    return DBCommandResult.createDBCommandResult(
      builder,
      this.dbCommandName,
      this.success,
      this.id,
      errortext
    )
  }
}

export class Result implements flatbuffers.IUnpackableObject<ResultT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Result {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsResult(bb: flatbuffers.ByteBuffer, obj?: Result): Result {
    return (obj || new Result()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsResult(bb: flatbuffers.ByteBuffer, obj?: Result): Result {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Result()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  codeOfResult(): ResultCode {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ResultCode.OK
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static startResult(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addCodeOfResult(builder: flatbuffers.Builder, codeOfResult: ResultCode) {
    builder.addFieldInt8(0, codeOfResult, ResultCode.OK)
  }

  static endResult(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createResult(builder: flatbuffers.Builder, codeOfResult: ResultCode): flatbuffers.Offset {
    Result.startResult(builder)
    Result.addCodeOfResult(builder, codeOfResult)
    return Result.endResult(builder)
  }

  unpack(): ResultT {
    return new ResultT(this.codeOfResult())
  }

  unpackTo(_o: ResultT): void {
    _o.codeOfResult = this.codeOfResult()
  }
}

export class ResultT implements flatbuffers.IGeneratedObject {
  constructor(public codeOfResult: ResultCode = ResultCode.OK) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return Result.createResult(builder, this.codeOfResult)
  }
}

export class Message implements flatbuffers.IUnpackableObject<MessageT> {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Message {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsMessage(bb: flatbuffers.ByteBuffer, obj?: Message): Message {
    return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  static getSizePrefixedRootAsMessage(bb: flatbuffers.ByteBuffer, obj?: Message): Message {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb)
  }

  typeOfMessageType(): MessageType {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : MessageType.NONE
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  typeOfMessage(obj: any): any | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static startMessage(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addTypeOfMessageType(builder: flatbuffers.Builder, typeOfMessageType: MessageType) {
    builder.addFieldInt8(0, typeOfMessageType, MessageType.NONE)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static addTypeOfMessage(builder: flatbuffers.Builder, typeOfMessageOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, typeOfMessageOffset, 0)
  }

  static endMessage(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    builder.requiredField(offset, 6) // type_of_message
    return offset
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static finishMessageBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {
    builder.finish(offset)
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  static finishSizePrefixedMessageBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {
    builder.finish(offset, undefined, true)
  }

  static createMessage(
    builder: flatbuffers.Builder,
    typeOfMessageType: MessageType,
    typeOfMessageOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    Message.startMessage(builder)
    Message.addTypeOfMessageType(builder, typeOfMessageType)
    Message.addTypeOfMessage(builder, typeOfMessageOffset)
    return Message.endMessage(builder)
  }

  unpack(): MessageT {
    return new MessageT(
      this.typeOfMessageType(),
      // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
      (() => {
        const temp = unionToMessageType(this.typeOfMessageType(), this.typeOfMessage.bind(this))
        if (temp === null) {
          return null
        }
        return temp.unpack()
      })()
    )
  }

  unpackTo(_o: MessageT): void {
    _o.typeOfMessageType = this.typeOfMessageType()
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    _o.typeOfMessage = (() => {
      const temp = unionToMessageType(this.typeOfMessageType(), this.typeOfMessage.bind(this))
      if (temp === null) {
        return null
      }
      return temp.unpack()
    })()
  }
}

export class MessageT implements flatbuffers.IGeneratedObject {
  constructor(
    public typeOfMessageType: MessageType = MessageType.NONE,
    public typeOfMessage: EventT | QueryResultT | QueryT | null = null
  ) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const typeOfMessage = builder.createObjectOffset(this.typeOfMessage)

    return Message.createMessage(builder, this.typeOfMessageType, typeOfMessage)
  }
}
